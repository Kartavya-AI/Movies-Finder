"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const recommendations_1 = require("../../tools/recommendations");
const tmdbClient_1 = require("../../services/tmdbClient");
const genreMap = __importStar(require("../../utils/genreMap"));
// 模拟依赖
jest.mock('../../services/tmdbClient');
jest.mock('../../utils/genreMap');
describe('getRecommendationsByGenre Tool', () => {
    // 初始化间谍/模拟对象
    const mockedTmdbClient = tmdbClient_1.tmdbClient;
    const mockedMapGenreToId = jest.spyOn(genreMap, 'mapGenreToId');
    const mockedGetGenreNameById = jest.spyOn(genreMap, 'getGenreNameById');
    beforeEach(() => {
        jest.clearAllMocks();
    });
    it('应该成功获取推荐并返回格式化字符串', async () => {
        // 模拟类型映射
        mockedMapGenreToId.mockReturnValue(35); // 假设35是喜剧类型
        mockedGetGenreNameById.mockReturnValue('喜剧');
        // 模拟API响应
        mockedTmdbClient.getRecommendationsByGenre.mockResolvedValue({
            page: 1,
            results: [
                {
                    id: 1,
                    name: '老友记',
                    overview: '六个朋友在纽约的生活故事',
                    first_air_date: '1994-09-22',
                    vote_average: 8.5
                },
                {
                    id: 2,
                    name: '生活大爆炸',
                    overview: '四个天才科学家和他们的邻居',
                    first_air_date: '2007-09-24',
                    vote_average: 8.2
                }
            ]
        });
        // 调用工具函数
        const result = await (0, recommendations_1.getRecommendationsByGenre)({ genre: '喜剧' });
        // 验证输出
        expect(result).toContain('根据您选择的喜剧，为您推荐以下剧集：');
        expect(result).toContain('1. 老友记 (1994): 8.5 - 六个朋友在纽约的生活故事');
        expect(result).toContain('2. 生活大爆炸 (2007): 8.2 - 四个天才科学家和他们的邻居');
        // 验证调用
        expect(mockedMapGenreToId).toHaveBeenCalledWith('喜剧');
        expect(mockedTmdbClient.getRecommendationsByGenre).toHaveBeenCalledWith(35);
    });
    it('当找不到类型时应该返回错误提示', async () => {
        // 模拟类型映射失败
        mockedMapGenreToId.mockReturnValue(undefined);
        // 调用工具函数
        const result = await (0, recommendations_1.getRecommendationsByGenre)({ genre: '未知类型' });
        // 验证输出
        expect(result).toContain('抱歉，无法识别您提供的类型"未知类型"');
        // 验证未调用API
        expect(mockedTmdbClient.getRecommendationsByGenre).not.toHaveBeenCalled();
    });
    it('当API返回空结果时应该返回相应提示', async () => {
        // 模拟类型映射
        mockedMapGenreToId.mockReturnValue(999); // 假设999是一个罕见类型
        mockedGetGenreNameById.mockReturnValue('罕见类型');
        // 模拟API响应为空结果
        mockedTmdbClient.getRecommendationsByGenre.mockResolvedValue({
            page: 1,
            results: []
        });
        // 调用工具函数
        const result = await (0, recommendations_1.getRecommendationsByGenre)({ genre: '罕见类型' });
        // 验证输出
        expect(result).toContain('抱歉，在"罕见类型"类型下没有找到推荐剧集');
    });
    it('当缺少参数时应该抛出错误', async () => {
        // 调用工具函数，传入空参数
        const result = await (0, recommendations_1.getRecommendationsByGenre)({ genre: '' });
        // 验证输出
        expect(result).toContain('获取推荐时发生错误');
    });
    it('当API调用失败时应该返回错误信息', async () => {
        // 模拟类型映射
        mockedMapGenreToId.mockReturnValue(35);
        // 模拟API调用失败
        mockedTmdbClient.getRecommendationsByGenre.mockRejectedValue(new Error('API错误'));
        // 调用工具函数
        const result = await (0, recommendations_1.getRecommendationsByGenre)({ genre: '喜剧' });
        // 验证输出
        expect(result).toContain('获取推荐时发生错误');
    });
});
